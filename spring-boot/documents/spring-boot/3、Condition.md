<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在前面的文章，我们已经看过 Spring Boot 如何实现<strong>自动配置</strong>的功能，但是，实际场景下，这显然不够。为什么呢？因为每个框架的<strong>配置</strong>，需要满足一定的<strong>条件</strong>，才应该进行<strong>自动配置</strong>。这时候，我们很自然就可以想到 Spring Boot 的 <strong>Condition</strong> 功能。不过呢，Condition 功能并不是 Spring Boot 所独有，而是在 Spring Framework 中就已经提供了。那么，究竟是什么样的关系呢，我们在 <a href="#">「2. Condition 演进史」</a> 来瞅瞅。</p>
<h1 id="2-Condition-演进史"><a href="#2-Condition-演进史" class="headerlink" title="2. Condition 演进史"></a>2. Condition 演进史</h1><h2 id="2-1-Profile-的出场"><a href="#2-1-Profile-的出场" class="headerlink" title="2.1 Profile 的出场"></a>2.1 Profile 的出场</h2><p>在 Spring3.1 的版本，为了满足不同环境注册不同的 Bean ，引入了 <code>@Profile</code> 注解。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"DEV"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// ... 单机 MySQL</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"PROD"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">prodDataSource</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// ... 集群 MySQL</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在测试环境下，我们注册单机 MySQL 的 DataSource Bean 。</li>
<li>在生产环境下，我们注册集群 MySQL 的 DataSource Bean 。</li>
</ul>
<hr>
<p><code>org.springframework.context.annotation.@Profile</code> ，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Profile.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile {</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The set of profiles for which the annotated component should be registered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] value();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是 Spring5 版本的 <code>@Profile</code> 注解的代码。它已经是经过 Condition 改造的实现。详细的，我们放在 <a href="#">「2.2 Condition」</a> 。</li>
<li><p>让我们在来看一眼 Spring3 版本的 <code>@Profile</code> 注解的代码。如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Profile.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>({</span><br><span class="line">	ANNOTATION_TYPE, <span class="comment">// @Profile may be used as a meta-annotation</span></span><br><span class="line">	TYPE             <span class="comment">// In conjunction with @Component and its derivatives</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String CANDIDATE_PROFILES_ATTRIB_NAME = <span class="string">"value"</span>;</span><br><span class="line"></span><br><span class="line">	String[] value();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以大体猜出，此时并没有将 Profile 作为 Condition 的一种情况。</li>
</ul>
</li>
</ul>
<h2 id="2-2-Condition-的出现"><a href="#2-2-Condition-的出现" class="headerlink" title="2.2 Condition 的出现"></a>2.2 Condition 的出现</h2><p>在 Spring4 的版本，正式出现 Condition 功能，体现在 <code>org.springframework.context.annotation.Condition</code> 接口，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Condition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>很简洁的一个接口，只有一个 <code>#matches(...)</code> 方法，用于判断是佛匹配。从参数中就可以看出，它是和注解配合，而这个注解便是 <code>@Conditional</code> 。</li>
</ul>
<p><code>org.springframework.context.annotation.@Conditional</code> 注解，也是在 Spring4 的版本，一起出现。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Conditional.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>({ElementType.TYPE, ElementType.METHOD})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional {</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以注解在<strong>方法</strong>、或者在<strong>类</strong>上，表示需要满足的条件（Condition）。</li>
<li>在 <a href="#">「2.1 Profile 的出现」</a> 小节中，我们已经看到 <code>@Profile</code> 上，有 <code>@Conditional(ProfileCondition.class)</code> 的注解，表示使用 <code>org.springframework.context.annotation.ProfileCondition</code> 作为条件。</li>
<li><p>当然，我们也可以直接在 Configuration 类上使用。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(XXXCondition.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">xxxObject</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>即，创建 <code>#xxxObject()</code> 方法对应的 Bean 对象，需要满足 XXXCondition 条件。</li>
</ul>
</li>
</ul>
<p>在 Spring5 中，艿艿整理了下目前提供的 Condition 实现类，如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/01.jpg" alt="Condition 实现类"></p>
<ul>
<li>显然，默认提供的 Condition 实现类非常少。</li>
</ul>
<h2 id="2-3-SpringBootCondition-的进击"><a href="#2-3-SpringBootCondition-的进击" class="headerlink" title="2.3 SpringBootCondition 的进击"></a>2.3 SpringBootCondition 的进击</h2><p>为了满足更加丰富的 Condition（条件）的需要，Spring Boot 进一步拓展了更多的实现类，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/02.jpg" alt="Spring Boot Condition 实现类"></p>
<ul>
<li><code>org.springframework.boot.autoconfigure.condition.SpringBootCondition</code> ，是 Spring Boot 实现 Condition 的抽象类，且是 Spring Boot 所有 Condition 实现类的基类。</li>
<li>分别对应如下注解：<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下。</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下。</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean 。</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下。</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下。</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件。</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web项 目的条件下。</li>
</ul>
</li>
</ul>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p>到了此处，我们基本算是理清了 Condition 的整个演进构成：</p>
<ul>
<li><code>@Profile</code> 注解，在 Spring3.1 提出，可以作为是 Condition 的雏形。</li>
<li>Condition 接口，在 Spring4 提出，是 Condition 的正式出现。</li>
<li>SpringCondition 抽象类，在 Spring Boot 实现，是对 Condition 进一步拓展。</li>
</ul>
<p>下面，我们就正式开始撸 Condition 相关的源码落。</p>
<h1 id="3-Condition-如何生效？"><a href="#3-Condition-如何生效？" class="headerlink" title="3. Condition 如何生效？"></a>3. Condition 如何生效？</h1><p>在上面的文章中，我们已经看到，<code>@Conditional</code> 注解，可以添加：</p>
<ul>
<li>类级别上</li>
<li>方法级别上</li>
</ul>
<blockquote>
<p>添加到注解上，相当于添加到类级别或者方法级别上。</p>
</blockquote>
<p>并且，一般情况下我们和配置类（Configuration）一起使用，但是实际上，我们也可以添加到普通的 Bean 类上。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// DemoController.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="meta">@Conditional</span>(TestCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>那么，究竟 Condition 是如何生效的呢？分成两种情况：</p>
<ul>
<li>方式一，<strong>配置类</strong>。添加到配置类（Configuration）上面。</li>
<li><p>方式二，<strong>创建 Bean 对象</strong>。添加到配置类（Configuration）、或者 Bean Class 的上面。</p>
<blockquote>
<p>本质上，方式二上的两种，都是创建 Bean 对象，所以统一处理方式即可。</p>
</blockquote>
</li>
</ul>
<p>假设，我们在 TestConfiguration 这个示例下进行测试，看看具体的调用链。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// TestConfiguration.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional</span>(TestCondition.class) <span class="comment">// 艿艿自己编写的 Condition 实现类，方式测试调试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(TestCondition.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">testObject</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCondition.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>本小节，不会讲特别细的源码。</p>
</blockquote>
<h2 id="3-1-方式一：配置类"><a href="#3-1-方式一：配置类" class="headerlink" title="3.1 方式一：配置类"></a>3.1 方式一：配置类</h2><p>在 TestCondition 的 <code>#matches(...)</code> 方法中，打个断点。看看<strong>方式一</strong>情况下的具体的表现。如下图所示：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/03.jpg" alt="调用栈"></p>
<ul>
<li>通过调用 <code>Condition#matches(...)</code> 方法，判断该是否匹配。如果不匹配，内部所有方法，都无法创建 Bean 对象。</li>
</ul>
<h2 id="3-2-方式二：创建-Bean-对象"><a href="#3-2-方式二：创建-Bean-对象" class="headerlink" title="3.2 方式二：创建 Bean 对象"></a>3.2 方式二：创建 Bean 对象</h2><p>在 TestCondition 的 <code>#matches(...)</code> 方法中，打个断点。看看<strong>方式二</strong>情况下的具体的表现。如下图所示：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/04.jpg" alt="调用栈"></p>
<ul>
<li>通过调用 <code>Condition#matches(...)</code> 方法，判断是否匹配。如果吧匹配，则不从该方法加载 BeanDefinition 。这样，就不会创建对应的 Bean 对象了。</li>
</ul>
<h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>至此，我们已经看到 Condition 如何生效。还是相对比较简单的。</p>
<p>下面，我们一起来看看 SpringBootCondition 如何实现它的进击。</p>
<h1 id="4-ProfileCondition"><a href="#4-ProfileCondition" class="headerlink" title="4. ProfileCondition"></a>4. ProfileCondition</h1><blockquote>
<p>艿艿：先插播下 ProfileCondition 的实现代码。</p>
</blockquote>
<p><code>org.springframework.context.annotation.ProfileCondition</code> ，实现 Condition 接口，给 <code>@Profile</code> 使用的 Condition 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ProfileCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">        <span class="comment">// 获得 @Profile 注解的属性</span></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">        <span class="comment">// 如果非空，进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 遍历所有 @Profile 的 value 属性</span></span><br><span class="line">            <span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) {</span><br><span class="line">                <span class="comment">// 判断 environment 有符合的 Profile ，则返回 true ，表示匹配</span></span><br><span class="line">                <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果没有，则返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果为空，就表示满足条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>核心逻辑，获得 <code>@Profile</code> 的 <code>value</code> 属性，和 <code>environment</code> 是否有匹配的。如果有，则表示匹配。</li>
</ul>
<h1 id="5-SpringBootCondition"><a href="#5-SpringBootCondition" class="headerlink" title="5. SpringBootCondition"></a>5. SpringBootCondition</h1><p><code>org.springframework.boot.autoconfigure.condition.SpringBootCondition</code> ，实现 Condition 接口，Spring Boot Condition 的<strong>抽象基类</strong>，主要用于提供相应的日志，帮助开发者判断哪些被进行加载。如下是其上的类注释：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base of all {<span class="doctag">@link</span> Condition} implementations used with Spring Boot. Provides sensible</span></span><br><span class="line"><span class="comment"> * logging to help the user diagnose what classes are loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-1-matches"><a href="#5-1-matches" class="headerlink" title="5.1 matches"></a>5.1 matches</h2><p>实现 <code>#matches(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法，实现匹配逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得注解的是方法名还是类名</span></span><br><span class="line">    String classOrMethodName = getClassOrMethodName(metadata);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;2&gt; 条件匹配结果</span></span><br><span class="line">        ConditionOutcome outcome = getMatchOutcome(context, metadata);</span><br><span class="line">        <span class="comment">// &lt;3&gt; 打印结果</span></span><br><span class="line">        logOutcome(classOrMethodName, outcome);</span><br><span class="line">        <span class="comment">// &lt;4&gt; 记录</span></span><br><span class="line">        recordEvaluation(context, classOrMethodName, outcome);</span><br><span class="line">        <span class="comment">// &lt;5&gt; 返回是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> outcome.isMatch();</span><br><span class="line">    } <span class="keyword">catch</span> (NoClassDefFoundError ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Could not evaluate condition on "</span> + classOrMethodName + <span class="string">" due to "</span></span><br><span class="line">                        + ex.getMessage() + <span class="string">" not "</span></span><br><span class="line">                        + <span class="string">"found. Make sure your own configuration does not rely on "</span></span><br><span class="line">                        + <span class="string">"that class. This can also happen if you are "</span></span><br><span class="line">                        + <span class="string">"@ComponentScanning a springframework package (e.g. if you "</span></span><br><span class="line">                        + <span class="string">"put a @ComponentScan in the default package by mistake)"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error processing condition on "</span> + getName(metadata), ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，调用 <code>#getClassOrMethodName(AnnotatedTypeMetadata metadata)</code> 方法，获得注解的是方法名还是类名。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getClassOrMethodName</span><span class="params">(AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">	<span class="comment">// 类</span></span><br><span class="line">	<span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> ClassMetadata) {</span><br><span class="line">		ClassMetadata classMetadata = (ClassMetadata) metadata;</span><br><span class="line">		<span class="keyword">return</span> classMetadata.getClassName();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 方法</span></span><br><span class="line">	MethodMetadata methodMetadata = (MethodMetadata) metadata;</span><br><span class="line">	<span class="keyword">return</span> methodMetadata.getDeclaringClassName() + <span class="string">"#"</span> + methodMetadata.getMethodName();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><code>&lt;2&gt;</code> 处，调用 <code>#getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata)</code> <strong>抽象</strong>方法，执行匹配，返回匹配结果。这是一个<strong>抽象</strong>方法，由子类进行实现。<ul>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionOutcome.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.boot.autoconfigure.condition.ConditionOutcome</code></a> ，匹配结果。</li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionMessage.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.boot.autoconfigure.condition.ConditionMessage</code></a> ，匹配消息。</li>
<li>以上的类，自己瞅瞅。简单~</li>
</ul>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#logOutcome(String classOrMethodName, ConditionOutcome outcome)</code> 方法，打印结果日志。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">logOutcome</span><span class="params">(String classOrMethodName, ConditionOutcome outcome)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) {</span><br><span class="line">		<span class="keyword">this</span>.logger.trace(getLogMessage(classOrMethodName, outcome));</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">getLogMessage</span><span class="params">(String classOrMethodName, ConditionOutcome outcome)</span> </span>{</span><br><span class="line">	StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	message.append(<span class="string">"Condition "</span>);</span><br><span class="line">	message.append(ClassUtils.getShortName(getClass()));</span><br><span class="line">	message.append(<span class="string">" on "</span>);</span><br><span class="line">	message.append(classOrMethodName);</span><br><span class="line">	message.append(outcome.isMatch() ? <span class="string">" matched"</span> : <span class="string">" did not match"</span>);</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(outcome.getMessage())) {</span><br><span class="line">		message.append(<span class="string">" due to "</span>);</span><br><span class="line">		message.append(outcome.getMessage());</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> message;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>#recordEvaluation(ConditionContext context, String classOrMethodName, ConditionOutcome outcome)</code> 方法，记录到 ConditionEvaluationReport 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordEvaluation</span><span class="params">(ConditionContext context, String classOrMethodName, ConditionOutcome outcome)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (context.getBeanFactory() != <span class="keyword">null</span>) {</span><br><span class="line">		ConditionEvaluationReport.get(context.getBeanFactory()).recordConditionEvaluation(classOrMethodName, <span class="keyword">this</span>, outcome);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 <a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/condition/ConditionEvaluationReport.java" rel="external nofollow noopener noreferrer" target="_blank">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport</a> 类，先不详细看，避免研究过深。</li>
</ul>
</li>
<li><p><code>&lt;5&gt;</code> 处，返回是否匹配。</p>
</li>
</ul>
<h2 id="5-2-anyMatches"><a href="#5-2-anyMatches" class="headerlink" title="5.2 anyMatches"></a>5.2 anyMatches</h2><p><code>#anyMatches(ConditionContext context, AnnotatedTypeMetadata metadata, Condition... conditions)</code> 方法，判断是否匹配指定的 Condition 们中的任一一个。代码如下：</p>
<blockquote>
<p>艿艿：总感觉这个方法，应该是个静态方法才合适。所以，胖友即酱油看看即可。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">anyMatches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata, Condition... conditions)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历 Condition</span></span><br><span class="line">    <span class="keyword">for</span> (Condition condition : conditions) {</span><br><span class="line">        <span class="comment">// 执行匹配</span></span><br><span class="line">        <span class="keyword">if</span> (matches(context, metadata, condition)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>遍历 <code>conditions</code> 数组，调用 <code>#matches(ConditionContext context, AnnotatedTypeMetadata metadata, Condition condition)</code> 方法，执行匹配。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata, Condition condition)</span> </span>{</span><br><span class="line">	<span class="comment">// 如果是 SpringBootCondition 类型，执行 SpringBootCondition 的直接匹配方法（无需日志）</span></span><br><span class="line">	<span class="keyword">if</span> (condition <span class="keyword">instanceof</span> SpringBootCondition) {</span><br><span class="line">		<span class="keyword">return</span> ((SpringBootCondition) condition).getMatchOutcome(context, metadata).isMatch();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> condition.matches(context, metadata);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>总的来说，SpringBootCondition 这个类，没啥好说，重点还是在子类。</p>
<h1 id="6-SpringBootCondition-的实现类"><a href="#6-SpringBootCondition-的实现类" class="headerlink" title="6. SpringBootCondition 的实现类"></a>6. SpringBootCondition 的实现类</h1><p>我们在回忆下，SpringBootCondition 的实现类，主要如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/02.jpg" alt="Spring Boot Condition 实现类"></p>
<p>显然，我们不会去看每一个类的 SpringBootCondition 的实现类。所以呢，艿艿也不会每个类都写。</p>
<blockquote>
<p>旁白君：偷懒都偷的如此猥琐，哈哈哈哈。</p>
</blockquote>
<h2 id="6-1-OnPropertyCondition"><a href="#6-1-OnPropertyCondition" class="headerlink" title="6.1 OnPropertyCondition"></a>6.1 OnPropertyCondition</h2><blockquote>
<p>艿艿：来来来，先看一个容易的（捏个软柿子）。</p>
</blockquote>
<p><code>org.springframework.boot.autoconfigure.condition.OnPropertyCondition</code> ，继承 SpringBootCondition 抽象类，给 <code>@ConditionalOnProperty</code> 使用的 Condition 实现类。</p>
<p>如果胖友不熟悉 <code>@ConditionalOnProperty</code> 注解，赶紧打开 <a href="https://www.jianshu.com/p/68a75c093023" rel="external nofollow noopener noreferrer" target="_blank">《@ConditionalOnProperty 来控制 Configuration 是否生效》</a> 学习 3 分钟~不能再多了。</p>
<h3 id="6-1-1-getMatchOutcome"><a href="#6-1-1-getMatchOutcome" class="headerlink" title="6.1.1 getMatchOutcome"></a>6.1.1 getMatchOutcome</h3><p><code>#getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法，获得匹配结果。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnPropertyCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">	<span class="comment">// &lt;1&gt; 获得 @ConditionalOnProperty 注解的属性</span></span><br><span class="line">	List&lt;AnnotationAttributes&gt; allAnnotationAttributes = annotationAttributesFromMultiValueMap(</span><br><span class="line">			metadata.getAllAnnotationAttributes(ConditionalOnProperty.class.getName()));</span><br><span class="line">	<span class="comment">// &lt;2&gt; 存储匹配和不匹配的结果消息结果</span></span><br><span class="line">	List&lt;ConditionMessage&gt; noMatch = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;ConditionMessage&gt; match = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">// &lt;3&gt; 遍历 annotationAttributes 属性数组，逐个判断是否匹配，并添加到结果</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes annotationAttributes : allAnnotationAttributes) {</span><br><span class="line">		ConditionOutcome outcome = determineOutcome(annotationAttributes, context.getEnvironment());</span><br><span class="line">		(outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage());</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;4.1&gt; 如果有不匹配的，则返回不匹配</span></span><br><span class="line">	<span class="keyword">if</span> (!noMatch.isEmpty()) {</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.of(noMatch));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;4.2&gt; 如果都匹配，则返回匹配</span></span><br><span class="line">	<span class="keyword">return</span> ConditionOutcome.match(ConditionMessage.of(match));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#annotationAttributesFromMultiValueMap(MultiValueMap&lt;String, Object&gt; multiValueMap)</code> 方法，获得 <code>@ConditionalOnProperty</code> 注解的属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnPropertyCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;AnnotationAttributes&gt; <span class="title">annotationAttributesFromMultiValueMap</span><span class="params">(MultiValueMap&lt;String, Object&gt; multiValueMap)</span> </span>{</span><br><span class="line">	List&lt;Map&lt;String, Object&gt;&gt; maps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	multiValueMap.forEach((key, value) -&gt; {</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.size(); i++) {</span><br><span class="line">			Map&lt;String, Object&gt; map;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; maps.size()) {</span><br><span class="line">				map = maps.get(i);</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">				maps.add(map);</span><br><span class="line">			}</span><br><span class="line">			map.put(key, value.get(i));</span><br><span class="line">		}</span><br><span class="line">	});</span><br><span class="line">	List&lt;AnnotationAttributes&gt; annotationAttributes = <span class="keyword">new</span> ArrayList&lt;&gt;(maps.size());</span><br><span class="line">	<span class="keyword">for</span> (Map&lt;String, Object&gt; map : maps) {</span><br><span class="line">		annotationAttributes.add(AnnotationAttributes.fromMap(map));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> annotationAttributes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>懒的看整个代码实现的过程，可以直接看最终执行的结果图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/05.jpg" alt="`annotationAttributes`"></li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，存储匹配和不匹配的结果消息结果。</p>
</li>
<li><code>&lt;3&gt;</code> 处，遍历 <code>annotationAttributes</code> 属性数组，逐个调用 <code>#determineOutcome(AnnotationAttributes annotationAttributes, PropertyResolver resolver)</code> 方法，判断是否匹配，并添加到结果。详细解析，见 <a href="#">「6.1.2 determineOutcome」</a> 。</li>
<li><code>&lt;4.1&gt;</code> 处，如果有不匹配的，则返回不匹配。返回结果示例如下：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/06.jpg" alt="不匹配"></li>
<li><code>&lt;4.2&gt;</code> 处，如果都匹配，则返回匹配。返回结果示例如下：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/07.jpg" alt="匹配"></li>
</ul>
<h3 id="6-1-2-determineOutcome"><a href="#6-1-2-determineOutcome" class="headerlink" title="6.1.2 determineOutcome"></a>6.1.2 determineOutcome</h3><p><code>#determineOutcome(AnnotationAttributes annotationAttributes, PropertyResolver resolver)</code> 方法，判断是否匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnPropertyCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">determineOutcome</span><span class="params">(AnnotationAttributes annotationAttributes, PropertyResolver resolver)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 解析成 Spec 对象</span></span><br><span class="line">    Spec spec = <span class="keyword">new</span> Spec(annotationAttributes);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 创建结果数组</span></span><br><span class="line">    List&lt;String&gt; missingProperties = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonMatchingProperties = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// &lt;3&gt; 收集是否不匹配的信息，到 missingProperties、nonMatchingProperties 中</span></span><br><span class="line">    spec.collectProperties(resolver, missingProperties, nonMatchingProperties);</span><br><span class="line">    <span class="comment">// &lt;4.1&gt; 如果有属性缺失，则返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!missingProperties.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec)</span><br><span class="line">                        .didNotFind(<span class="string">"property"</span>, <span class="string">"properties"</span>).items(Style.QUOTE, missingProperties));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;4.2&gt; 如果有属性不匹配，则返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!nonMatchingProperties.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec)</span><br><span class="line">                        .found(<span class="string">"different value in property"</span>, <span class="string">"different value in properties"</span>).items(Style.QUOTE, nonMatchingProperties));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;4.3&gt; 返回匹配</span></span><br><span class="line">    <span class="keyword">return</span> ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnProperty.class, spec).because(<span class="string">"matched"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，解析成 Spec 对象。Spec 是 OnPropertyCondition 的内部静态类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnPropertyCondition#Spec.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Spec</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 属性前缀</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否有指定值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String havingValue;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 属性名</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] names;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果属性不存在，是否认为是匹配的。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果为 false 时，就认为属性丢失，即不匹配。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> matchIfMissing;</span><br><span class="line"></span><br><span class="line">	Spec(AnnotationAttributes annotationAttributes) {</span><br><span class="line">		String prefix = annotationAttributes.getString(<span class="string">"prefix"</span>).trim();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(prefix) &amp;&amp; !prefix.endsWith(<span class="string">"."</span>)) {</span><br><span class="line">			prefix = prefix + <span class="string">"."</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">		<span class="keyword">this</span>.havingValue = annotationAttributes.getString(<span class="string">"havingValue"</span>);</span><br><span class="line">		<span class="keyword">this</span>.names = getNames(annotationAttributes);</span><br><span class="line">		<span class="keyword">this</span>.matchIfMissing = annotationAttributes.getBoolean(<span class="string">"matchIfMissing"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 value 或者 name 属性种，获得值</span></span><br><span class="line">	<span class="keyword">private</span> String[] getNames(Map&lt;String, Object&gt; annotationAttributes) {</span><br><span class="line">		String[] value = (String[]) annotationAttributes.get(<span class="string">"value"</span>);</span><br><span class="line">		String[] name = (String[]) annotationAttributes.get(<span class="string">"name"</span>);</span><br><span class="line">		Assert.state(value.length &gt; <span class="number">0</span> || name.length &gt; <span class="number">0</span>, <span class="string">"The name or value attribute of @ConditionalOnProperty must be specified"</span>);</span><br><span class="line">		Assert.state(value.length == <span class="number">0</span> || name.length == <span class="number">0</span>, <span class="string">"The name and value attributes of @ConditionalOnProperty are exclusive"</span>);</span><br><span class="line">		<span class="keyword">return</span> (value.length &gt; <span class="number">0</span>) ? value : name;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ... 省略其它方法先~</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，创建结果数组。</p>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>Spec#collectProperties(PropertyResolver resolver, List&lt;String&gt; missing, List&lt;String&gt; nonMatching)</code> 方法，收集是否不匹配的信息，到 <code>missingProperties</code>、<code>nonMatchingProperties</code> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnPropertyCondition#Spec.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectProperties</span><span class="params">(PropertyResolver resolver, List&lt;String&gt; missing, List&lt;String&gt; nonMatching)</span> </span>{</span><br><span class="line">	<span class="comment">// 遍历 names 数组</span></span><br><span class="line">	<span class="keyword">for</span> (String name : <span class="keyword">this</span>.names) {</span><br><span class="line">		<span class="comment">// 获得完整的 key</span></span><br><span class="line">		String key = <span class="keyword">this</span>.prefix + name;</span><br><span class="line">		<span class="comment">// 如果存在指定属性</span></span><br><span class="line">		<span class="keyword">if</span> (resolver.containsProperty(key)) {</span><br><span class="line">			<span class="comment">// 匹配值是否匹配</span></span><br><span class="line">			<span class="keyword">if</span> (!isMatch(resolver.getProperty(key), <span class="keyword">this</span>.havingValue)) {</span><br><span class="line">				nonMatching.add(name);</span><br><span class="line">			}</span><br><span class="line">		<span class="comment">// 如果不存在指定属性</span></span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">// 如果属性为空，并且 matchIfMissing 为 false ，则添加到 missing 中</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.matchIfMissing) {</span><br><span class="line">				missing.add(name);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String value, String requiredValue)</span> </span>{</span><br><span class="line">	<span class="comment">// 如果 requiredValue 非空，则进行匹配</span></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(requiredValue)) {</span><br><span class="line">		<span class="keyword">return</span> requiredValue.equalsIgnoreCase(value);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果 requiredValue 为空，要求值不为 false</span></span><br><span class="line">	<span class="keyword">return</span> !<span class="string">"false"</span>.equalsIgnoreCase(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>匹配的逻辑，胖友自己瞅瞅。可能比较绕的逻辑是，<code>matchIfMissing</code> 那块，也就看两眼就明白。</li>
</ul>
</li>
<li><code>&lt;4.1&gt;</code> 处，如果有属性缺失，则返回不匹配。</li>
<li><code>&lt;4.2&gt;</code> 处，如果有属性不匹配，则返回不匹配。</li>
<li><code>&lt;4.3&gt;</code> 处，返回匹配。</li>
</ul>
<h2 id="6-2-其它实现类"><a href="#6-2-其它实现类" class="headerlink" title="6.2 其它实现类"></a>6.2 其它实现类</h2><p>SpringBootCondition 的其它实现类，胖友可以自己去瞅瞅啦。当然，有部分实现类，我们会在 <a href="#">「8. FilteringSpringBootCondition」</a> 分享。 </p>
<h1 id="7-AutoConfigurationImportFilter"><a href="#7-AutoConfigurationImportFilter" class="headerlink" title="7. AutoConfigurationImportFilter"></a>7. AutoConfigurationImportFilter</h1><p>在 <a href="http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/">《精尽 Spring Boot 源码分析 —— 自动配置》</a> 一文中，我们埋了一个 <code>AutoConfigurationImportSelector#filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法的坑，没有进行详细解析。所以呢，这一节我们将填掉这个坑。</p>
<p><code>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</code> 接口，用于过滤掉无需自动引入的自动配置类（Configuration）。正如其类上的注释：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportFilter.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter that can be registered in {<span class="doctag">@code</span> spring.factories} to limit the</span></span><br><span class="line"><span class="comment"> * auto-configuration classes considered. This interface is designed to allow fast removal</span></span><br><span class="line"><span class="comment"> * of auto-configuration classes before their bytecode is even read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重点是 <code>"fast removal of auto-configuration classes before their bytecode is even read"</code> 。因为自动配置类可能会很多，如果无需使用，而将字节码读取到内存中，这个是一种浪费。</li>
</ul>
<p>AutoConfigurationImportFilter 的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportFilter.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoConfigurationImportFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply the filter to the given auto-configuration class candidates.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> autoConfigurationClasses the auto-configuration classes being considered.</span></span><br><span class="line"><span class="comment">	 * This array may contain {<span class="doctag">@code</span> null} elements. Implementations should not change the</span></span><br><span class="line"><span class="comment">	 * values in this array.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> autoConfigurationMetadata access to the meta-data generated by the</span></span><br><span class="line"><span class="comment">	 * auto-configure annotation processor</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a boolean array indicating which of the auto-configuration classes should</span></span><br><span class="line"><span class="comment">	 * be imported. The returned array must be the same size as the incoming</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@code</span> autoConfigurationClasses} parameter. Entries containing {<span class="doctag">@code</span> false} will</span></span><br><span class="line"><span class="comment">	 * not be imported.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">boolean</span>[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将传入的 <code>autoConfigurationClasses</code> 配置类们，根据 <code>autoConfigurationMetadata</code> 的元数据（主要是注解信息），进行匹配，判断是否需要引入，然后返回的 <code>boolean[]</code> 结果。</li>
<li>并且，<code>boolean[]</code> 结果和 <code>autoConfigurationClasses</code> 配置类们是一一对应的关系噢。假设 <code>autoConfigurationClasses[0]</code> 对应的 <code>boolean[0]</code> 为 <code>false</code> ，表示无需引入，反之则需要引入。</li>
</ul>
<h2 id="7-1-AutoConfigurationImportFilter-类图"><a href="#7-1-AutoConfigurationImportFilter-类图" class="headerlink" title="7.1 AutoConfigurationImportFilter 类图"></a>7.1 AutoConfigurationImportFilter 类图</h2><p>AutoConfigurationImportFilter 的子类如下图所示：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/08.jpg" alt="AutoConfigurationImportFilter 类图"></p>
<ul>
<li>从图中，我们很容易就看出，AutoConfigurationImportFilter 的最终实现类，都是构建在 SpringBootCondition 之上。😈 不过这也很正常，因为 Condition 本身提供的一个功能，就是作为配置类（Configuration）是否能够符合条件被引入。</li>
</ul>
<h2 id="7-2-FilteringSpringBootCondition"><a href="#7-2-FilteringSpringBootCondition" class="headerlink" title="7.2 FilteringSpringBootCondition"></a>7.2 FilteringSpringBootCondition</h2><p><code>org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition</code> ，继承 SpringBootCondition 抽象类，实现 AutoConfigurationImportFilter、BeanFactoryAware、BeanClassLoaderAware 接口，作为<strong>具有 AutoConfigurationImportFilter 功能</strong>的 SpringBootCondition 的抽象基类。</p>
<blockquote>
<p>注意，上面特意加黑的“具有 AutoConfigurationImportFilter 功能”。</p>
</blockquote>
<p>FilteringSpringBootCondition 的基本属性，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"><span class="keyword">private</span> ClassLoader beanClassLoader;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过 Spring Aware 机制，进行注入。</li>
</ul>
<h3 id="7-2-1-match"><a href="#7-2-1-match" class="headerlink" title="7.2.1 match"></a>7.2.1 match</h3><p>实现 <code>#match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法，执行批量的匹配，并返回匹配结果。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 来自 AutoConfigurationImportFilter 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得 ConditionEvaluationReport 对象</span></span><br><span class="line">    ConditionEvaluationReport report = ConditionEvaluationReport.find(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 执行批量的匹配，并返回匹配结果</span></span><br><span class="line">    ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// &lt;3.1&gt; 创建 match 数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] match = <span class="keyword">new</span> <span class="keyword">boolean</span>[outcomes.length];</span><br><span class="line">    <span class="comment">// &lt;3.2&gt; 遍历 outcomes 结果数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcomes.length; i++) {</span><br><span class="line">        <span class="comment">// &lt;3.2.1&gt; 赋值 match 数组</span></span><br><span class="line">        match[i] = (outcomes[i] == <span class="keyword">null</span> || outcomes[i].isMatch()); <span class="comment">// 如果返回结果结果为空，也认为匹配</span></span><br><span class="line">        <span class="comment">// &lt;3.2.2&gt; 如果不匹配，打印日志和记录。</span></span><br><span class="line">        <span class="keyword">if</span> (!match[i] &amp;&amp; outcomes[i] != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            logOutcome(autoConfigurationClasses[i], outcomes[i]);</span><br><span class="line">            <span class="comment">// 记录</span></span><br><span class="line">            <span class="keyword">if</span> (report != <span class="keyword">null</span>) {</span><br><span class="line">                report.recordConditionEvaluation(autoConfigurationClasses[i], <span class="keyword">this</span>, outcomes[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.3&gt; 返回 match 数组</span></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从实现上，这个方法和 <code>SpringBootCondition#match(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法，基本是一致的。或者说，是它的批量版本。</li>
<li><code>&lt;1&gt;</code> 处，获得 ConditionEvaluationReport 对象。</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata)</code> <strong>抽象</strong>方法，执行批量的匹配，并返回匹配结果。这是一个抽象方法，由子类进行实现。</li>
<li><code>&lt;3.1&gt;</code> 处，创建 <code>match</code> 数组。</li>
<li><code>&lt;3.2&gt;</code> 处，遍历 <code>outcomes</code> 结果数组。<ul>
<li><code>&lt;3.2.1&gt;</code> 处，赋值 <code>match</code> 数组的当前元素。</li>
<li><code>&lt;3.2.2&gt;</code> 处，如果不匹配，打印日志和记录。其中，<code>#logOutcome(...)</code> 方法，就是调用父类 SpringBootCondition 的方法。</li>
</ul>
</li>
<li><code>&lt;3.3&gt;</code> 处，返回 <code>match</code> 数组。</li>
</ul>
<h3 id="7-2-2-ClassNameFilter"><a href="#7-2-2-ClassNameFilter" class="headerlink" title="7.2.2 ClassNameFilter"></a>7.2.2 ClassNameFilter</h3><p>ClassNameFilter ，是 FilteringSpringBootCondition 的内部类，提供判断类是否存在的功能。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition#ClassNameFilter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> ClassNameFilter {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定类存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PRESENT {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> isPresent(className, classLoader);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定类不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MISSING {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> !isPresent(className, classLoader);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">(String className, ClassLoader classLoader)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) {</span><br><span class="line">            classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            forName(className, classLoader);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载指定类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className, ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> classLoader.loadClass(className);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>里面提供了两个实现类，且是单例。</li>
<li>代码比较简单，胖友 5 秒看懂。</li>
</ul>
<h3 id="7-2-3-filter"><a href="#7-2-3-filter" class="headerlink" title="7.2.3 filter"></a>7.2.3 filter</h3><blockquote>
<p>该方法，提供给子类使用。</p>
</blockquote>
<p><code>#filter(Collection&lt;String&gt; classNames, ClassNameFilter classNameFilter, ClassLoader classLoader)</code> 方法，通过使用 ClassNameFilter 类，过滤出符合条件的类名的数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(Collection&lt;String&gt; classNames, ClassNameFilter classNameFilter, ClassLoader classLoader)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果为空，则返回空结果</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(classNames)) {</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 matches 数组</span></span><br><span class="line">    List&lt;String&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.size());</span><br><span class="line">    <span class="comment">// 遍历 classNames 数组，使用 ClassNameFilter 进行判断，是否匹配。</span></span><br><span class="line">    <span class="keyword">for</span> (String candidate : classNames) {</span><br><span class="line">        <span class="keyword">if</span> (classNameFilter.matches(candidate, classLoader)) {</span><br><span class="line">            matches.add(candidate);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-2-3-AutoConfigurationImportFilter-的使用"><a href="#7-2-3-AutoConfigurationImportFilter-的使用" class="headerlink" title="7.2.3 AutoConfigurationImportFilter 的使用"></a>7.2.3 AutoConfigurationImportFilter 的使用</h2><p>在 <code>AutoConfigurationImportSelector#filter(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法中，我们可以看到 AutoConfigurationImportFilter 的使用，过滤可以忽略的配置类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations, AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>{</span><br><span class="line"><span class="comment">//      // &lt;0&gt; 这里是艿艿乱加的。</span></span><br><span class="line"><span class="comment">//      if (true) {</span></span><br><span class="line"><span class="comment">//          return configurations;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 声明需要用到的变量</span></span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime(); <span class="comment">// 记录开始时间，用于下面统计消耗的时间</span></span><br><span class="line">    String[] candidates = StringUtils.toStringArray(configurations); <span class="comment">// 配置类的数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] skip = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length]; <span class="comment">// 每个配置类是否需要忽略的数组，通过下标互相索引</span></span><br><span class="line">    <span class="keyword">boolean</span> skipped = <span class="keyword">false</span>; <span class="comment">// 是否有需要忽略的</span></span><br><span class="line">    <span class="comment">// &lt;2&gt; 遍历 AutoConfigurationImportFilter 数组，逐个匹配</span></span><br><span class="line">    <span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) {</span><br><span class="line">        <span class="comment">// &lt;2.1&gt; 设置 AutoConfigurationImportFilter 的属性们</span></span><br><span class="line">        invokeAwareMethods(filter);</span><br><span class="line">        <span class="comment">// &lt;2.2&gt; 执行批量匹配，并返回匹配结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// &lt;2.3&gt; 遍历匹配结果，判断哪些需要忽略</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (!match[i]) { <span class="comment">// 如果有不匹配的</span></span><br><span class="line">                skip[i] = <span class="keyword">true</span>;</span><br><span class="line">                candidates[i] = <span class="keyword">null</span>; <span class="comment">// 标记为空，循环的下一次，就无需匹配它了。</span></span><br><span class="line">                skipped = <span class="keyword">true</span>; <span class="comment">// 标记存在不匹配的</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.1&gt; 如果没有需要忽略的，直接返回 configurations 即可</span></span><br><span class="line">    <span class="keyword">if</span> (!skipped) {</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.2&gt; 如果存在需要忽略的，构建新的数组，排除掉忽略的</span></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!skip[i]) {</span><br><span class="line">            result.add(candidates[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 打印，消耗的时间，已经排除的数量</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">        <span class="keyword">int</span> numberFiltered = configurations.size() - result.size();</span><br><span class="line">        logger.trace(<span class="string">"Filtered "</span> + numberFiltered + <span class="string">" auto configuration class in "</span></span><br><span class="line">                + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)</span><br><span class="line">                + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;0&gt;</code> 处，这里是艿艿调皮加的。用于测试，如果去掉这块逻辑，是否需有影响。答案当然是，<strong>没有影响</strong>。这里就先不说原因，胖友自己思考下。实际上，本文也已经提及为什么了。</li>
<li><code>&lt;1&gt;</code> 处，声明需要用到的变量。每个变量，已经添加其对应的注释，不再赘述。</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#getAutoConfigurationImportFilters()</code> 方法，加载指定类型 AutoConfigurationImportFilter 对应的，在 <code>META-INF/spring.factories</code> 里的类名的数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportFilter&gt; <span class="title">getAutoConfigurationImportFilters</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>例如：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/09.jpg" alt="`filters`"></li>
<li>就是我们看到的 AutoConfigurationImportFilter 的三个最终实现类。</li>
</ul>
</li>
<li><p><code>&lt;2.1&gt;</code>、<code>&lt;2.3&gt;</code>、<code>&lt;2.3&gt;</code> 处，就是对 <code>AutoConfigurationImportFilter#filter(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法的调用，妥妥的。是不是有点顺畅了。</p>
</li>
<li><code>&lt;3.1&gt;</code> 处，如果没有需要忽略的，直接返回 <code>configurations</code> 即可。</li>
<li><code>&lt;3.2&gt;</code> 处，如果存在需要忽略的，构建新的数组，排除掉忽略的。</li>
</ul>
<p>当然，加载到的自动化配置类（Configuration）也会存在使用 <code>@ConditionalOnProperty</code> 等其它条件注解，但是不会在此处被过滤掉。艿艿猜测的原因，可能配置会从外部加载，此时暂时不太好判断。😈 不一定正确，可以星球讨论一波哟。</p>
<h1 id="8-FilteringSpringBootCondition-的实现类"><a href="#8-FilteringSpringBootCondition-的实现类" class="headerlink" title="8. FilteringSpringBootCondition 的实现类"></a>8. FilteringSpringBootCondition 的实现类</h1><h2 id="8-1-OnClassCondition"><a href="#8-1-OnClassCondition" class="headerlink" title="8.1 OnClassCondition"></a>8.1 OnClassCondition</h2><p><code>org.springframework.boot.autoconfigure.condition.OnClassCondition</code> ，继承 FilteringSpringBootCondition 抽象类，给 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingClass</code> 使用的 Condition 实现类。</p>
<h3 id="8-1-1-getOutcomes"><a href="#8-1-1-getOutcomes" class="headerlink" title="8.1.1 getOutcomes"></a>8.1.1 getOutcomes</h3><p>实现 <code>#getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 来自 FilteringSpringBootCondition 抽象类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line">    <span class="comment">// Split the work and perform half in a background thread. Using a single</span></span><br><span class="line">    <span class="comment">// additional thread seems to offer the best performance. More threads make</span></span><br><span class="line">    <span class="comment">// things worse</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 在后台线程中将工作一分为二。原因是：</span></span><br><span class="line">    <span class="comment">// * 使用单一附加线程，似乎提供了最好的性能。</span></span><br><span class="line">    <span class="comment">// * 多个线程，使事情变得更糟</span></span><br><span class="line">    <span class="keyword">int</span> split = autoConfigurationClasses.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// &lt;2.1&gt; 将前一半，创建一个 OutcomesResolver 对象（新线程）</span></span><br><span class="line">    OutcomesResolver firstHalfResolver = createOutcomesResolver(autoConfigurationClasses, <span class="number">0</span>, split, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// &lt;2.2&gt; 将后一半，创建一个 OutcomesResolver 对象</span></span><br><span class="line">    OutcomesResolver secondHalfResolver = <span class="keyword">new</span> StandardOutcomesResolver(autoConfigurationClasses, split, autoConfigurationClasses.length, autoConfigurationMetadata, getBeanClassLoader());</span><br><span class="line">    <span class="comment">// 执行解析（匹配）</span></span><br><span class="line">    ConditionOutcome[] secondHalf = secondHalfResolver.resolveOutcomes(); <span class="comment">// &lt;3.1&gt;</span></span><br><span class="line">    ConditionOutcome[] firstHalf =  firstHalfResolver.resolveOutcomes(); <span class="comment">// &lt;3.2&gt;</span></span><br><span class="line">    <span class="comment">// &lt;4&gt; 创建 outcomes 结果数组，然后合并结果，最后返回</span></span><br><span class="line">    ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[autoConfigurationClasses.length];</span><br><span class="line">    System.arraycopy(firstHalf, <span class="number">0</span>, outcomes, <span class="number">0</span>, firstHalf.length);</span><br><span class="line">    System.arraycopy(secondHalf, <span class="number">0</span>, outcomes, split, secondHalf.length);</span><br><span class="line">    <span class="keyword">return</span> outcomes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，考虑到配置类（Configuration）配置的 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingClass</code> 注解中的类可能比较多，所以采用多线程提升效率。但是经过测试，分成两个线程，效率是最好的，所以这里才出现了 <code>autoConfigurationClasses.length / 2</code> 代码。</li>
<li><p><code>&lt;2.1&gt;</code> 处，调用 <code>#createOutcomesResolver(String[] autoConfigurationClasses, int start, int end, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法，创建一个 OutcomesResolver 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> OutcomesResolver <span class="title">createOutcomesResolver</span><span class="params">(String[] autoConfigurationClasses, <span class="keyword">int</span> start, <span class="keyword">int</span> end, AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>{</span><br><span class="line">	OutcomesResolver outcomesResolver = <span class="keyword">new</span> StandardOutcomesResolver(autoConfigurationClasses, start, end, autoConfigurationMetadata, getBeanClassLoader());</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ThreadedOutcomesResolver(outcomesResolver);</span><br><span class="line">	} <span class="keyword">catch</span> (AccessControlException ex) {</span><br><span class="line">		<span class="keyword">return</span> outcomesResolver;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>首先，创建了一个 StandardOutcomesResolver 对象 <code>outcomesResolver</code> 。</li>
<li>然后，创建了 ThreadedOutcomesResolver 对象，将 <code>outcomesResolver</code> 包装在其中。注意噢，下文我们会看到，ThreadedOutcomesResolver 是启动了一个新线程，执行 StandardOutcomesResolver 的逻辑。</li>
</ul>
</li>
<li><p><code>&lt;2.2&gt;</code> 处，将后一半，创建一个 StandardOutcomesResolver 对象。</p>
</li>
<li>😈 注意哟，创建的 StandardOutcomesResolver、ThreadedOutcomesResolver 对象，都是 OutcomesResolver 的子类。</li>
<li><code>&lt;3.1&gt;</code> 处，调用后一半的 <code>StandardOutcomesResolver#resolveOutcomes()</code> 方法，执行解析（匹配）。</li>
<li><code>&lt;3.2&gt;</code> 处，调用前一半的 <code>ThreadedOutcomesResolver#resolveOutcomes()</code> 方法，执行解析（匹配）。在 ThreadedOutcomesResolver 的实现里，会使用 <code>Thread#join()</code> 方法，保证新起的线程，能完成它的任务。这也是为什么，ThreadedOutcomesResolver 后执行的原因。</li>
<li><code>&lt;4&gt;</code> 处，创建 <code>outcomes</code> 结果数组，然后合并结果，最后返回。</li>
</ul>
<h3 id="8-1-2-OutcomesResolver"><a href="#8-1-2-OutcomesResolver" class="headerlink" title="8.1.2 OutcomesResolver"></a>8.1.2 OutcomesResolver</h3><p>OutcomesResolver ，是 OnClassCondition 的内部接口，结果解析器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#OutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutcomesResolver</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	ConditionOutcome[] resolveOutcomes();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>它的实现类有：</p>
<ul>
<li><a href="#">「8.1.3 ThreadedOutcomesResolver」</a></li>
<li><a href="#">「8.1.4 StandardOutcomesResolver」</a></li>
</ul>
<h3 id="8-1-3-ThreadedOutcomesResolver"><a href="#8-1-3-ThreadedOutcomesResolver" class="headerlink" title="8.1.3 ThreadedOutcomesResolver"></a>8.1.3 ThreadedOutcomesResolver</h3><p>ThreadedOutcomesResolver ，是 OnClassCondition 的内部类，实现 OutcomesResolver 接口，开启线程，执行 OutcomesResolver 的逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#ThreadedOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedOutcomesResolver</span> <span class="keyword">implements</span> <span class="title">OutcomesResolver</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新起的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件匹配结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ConditionOutcome[] outcomes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadedOutcomesResolver</span><span class="params">(OutcomesResolver outcomesResolver)</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;1.1&gt; 创建线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; <span class="keyword">this</span>.outcomes = outcomesResolver.resolveOutcomes());</span><br><span class="line">        <span class="comment">// &lt;1.2&gt; 启动线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() {</span><br><span class="line">        <span class="comment">// &lt;2.1&gt; 等待线程执行结束</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.thread.join();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException ex) {</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// &lt;2.2&gt; 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.outcomes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1.1&gt;</code>、<code>&lt;1.2&gt;</code> 处，在构建方法中，创建新的线程，并启动线程，从而调用 <code>OutcomesResolver#resolveOutcomes()</code> 方法，执行匹配逻辑。</li>
<li><code>&lt;2.1&gt;</code> 处，等待线程执行结束。</li>
<li><code>&lt;2.2&gt;</code> 处，返回结果。</li>
<li>😈 是不是这里一看，就明白 <a href="#">「8.1.1 getOutcomes」</a> 中，是这样的调用顺序了。</li>
</ul>
<h3 id="8-1-4-StandardOutcomesResolver"><a href="#8-1-4-StandardOutcomesResolver" class="headerlink" title="8.1.4 StandardOutcomesResolver"></a>8.1.4 StandardOutcomesResolver</h3><p>StandardOutcomesResolver ，是 OnClassCondition 的内部类，实现 OutcomesResolver 接口，<strong>标准的</strong> StandardOutcomesResolver 实现类。</p>
<h4 id="8-1-4-1-构造方法"><a href="#8-1-4-1-构造方法" class="headerlink" title="8.1.4.1 构造方法"></a>8.1.4.1 构造方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardOutcomesResolver</span> <span class="keyword">implements</span> <span class="title">OutcomesResolver</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有的配置类的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] autoConfigurationClasses;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配的 {<span class="doctag">@link</span> #autoConfigurationClasses} 开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配的 {<span class="doctag">@link</span> #autoConfigurationClasses} 结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AutoConfigurationMetadata autoConfigurationMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StandardOutcomesResolver</span><span class="params">(String[] autoConfigurationClasses, <span class="keyword">int</span> start, <span class="keyword">int</span> end, AutoConfigurationMetadata autoConfigurationMetadata, ClassLoader beanClassLoader)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.autoConfigurationClasses = autoConfigurationClasses;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.autoConfigurationMetadata = autoConfigurationMetadata;</span><br><span class="line">        <span class="keyword">this</span>.beanClassLoader = beanClassLoader;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略无关的方法先</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="8-1-4-2-resolveOutcomes"><a href="#8-1-4-2-resolveOutcomes" class="headerlink" title="8.1.4.2 resolveOutcomes"></a>8.1.4.2 resolveOutcomes</h4><p><code>#resolveOutcomes()</code> 方法，执行批量匹配，并返回结果。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() {</span><br><span class="line">    <span class="keyword">return</span> getOutcomes(<span class="keyword">this</span>.autoConfigurationClasses, <span class="keyword">this</span>.start, <span class="keyword">this</span>.end, <span class="keyword">this</span>.autoConfigurationMetadata);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, <span class="keyword">int</span> start, <span class="keyword">int</span> end, AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line">    <span class="comment">// 创建 ConditionOutcome 结构数组</span></span><br><span class="line">    ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[end - start];</span><br><span class="line">    <span class="comment">// 遍历 autoConfigurationClasses 数组，从 start 到 end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) {</span><br><span class="line">        String autoConfigurationClass = autoConfigurationClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (autoConfigurationClass != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// &lt;1&gt; 获得指定自动配置类的 @ConditionalOnClass 注解的要求类</span></span><br><span class="line">            String candidates = autoConfigurationMetadata.get(autoConfigurationClass, <span class="string">"ConditionalOnClass"</span>);</span><br><span class="line">            <span class="keyword">if</span> (candidates != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 执行匹配</span></span><br><span class="line">                outcomes[i - start] = getOutcome(candidates);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> outcomes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，获得指定自动配置类的 <code>@ConditionalOnClass</code> 注解的要求类。例如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-02-15/10.jpg" alt="`candidates` 示例"></li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>#getOutcome(String candidates)</code> 方法，执行匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String candidates)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果没有 , ，说明只有一个，直接匹配即可</span></span><br><span class="line">        <span class="keyword">if</span> (!candidates.contains(<span class="string">","</span>)) {</span><br><span class="line">            <span class="keyword">return</span> getOutcome(candidates, <span class="keyword">this</span>.beanClassLoader); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果有 , ，说明有多个，逐个匹配</span></span><br><span class="line">        <span class="keyword">for</span> (String candidate : StringUtils.commaDelimitedListToStringArray(candidates)) {</span><br><span class="line">            <span class="comment">// 执行匹配</span></span><br><span class="line">            ConditionOutcome outcome = getOutcome(candidate, <span class="keyword">this</span>.beanClassLoader); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">            <span class="comment">// 如果存在不匹配，则返回该结果</span></span><br><span class="line">            <span class="keyword">if</span> (outcome != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> outcome;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="comment">// We'll get another chance later</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#getOutcome(String className, ClassLoader classLoader)</code> 方法，执行匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition#StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String className, ClassLoader classLoader)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (ClassNameFilter.MISSING.matches(className, classLoader)) {</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage</span><br><span class="line">				.forCondition(ConditionalOnClass.class).didNotFind(<span class="string">"required class"</span>).items(Style.QUOTE, className));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过使用 <code>ClassNameFilter.MISSING</code> 来，进行匹配类是否不存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看到此处，我们会发现 <a href="#">「8.1.1 getOutcomes」</a> 的整个逻辑，暂时只做了 <code>@ConditionalOnClass</code> 注解的条件匹配，还有一个 <code>@ConditionalOnMissingClass</code> 注解呢？答案在 <a href="#">「8.1.5 getMatchOutcome」</a> 。</p>
<h3 id="8-1-5-getMatchOutcome"><a href="#8-1-5-getMatchOutcome" class="headerlink" title="8.1.5 getMatchOutcome"></a>8.1.5 getMatchOutcome</h3><p><code>#getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法，执行 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解的匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 来自 SpringBootCondition 抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 声明变量</span></span><br><span class="line">    ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">    ConditionMessage matchMessage = ConditionMessage.empty(); <span class="comment">// 匹配的信息</span></span><br><span class="line">    <span class="comment">// &lt;2&gt; 获得 `@ConditionalOnClass` 注解的属性</span></span><br><span class="line">    List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</span><br><span class="line">    <span class="keyword">if</span> (onClasses != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 执行匹配，看看是否有缺失的</span></span><br><span class="line">        List&lt;String&gt; missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);</span><br><span class="line">        <span class="comment">// 如果有不匹配的，返回不匹配信息</span></span><br><span class="line">        <span class="keyword">if</span> (!missing.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</span><br><span class="line">                    .didNotFind(<span class="string">"required class"</span>, <span class="string">"required classes"</span>).items(Style.QUOTE, missing));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果匹配，添加到 matchMessage 中</span></span><br><span class="line">        matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</span><br><span class="line">                .found(<span class="string">"required class"</span>, <span class="string">"required classes"</span>).items(Style.QUOTE, filter(onClasses, ClassNameFilter.PRESENT, classLoader));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3&gt; 获得 `@ConditionalOnMissingClass` 注解的属性</span></span><br><span class="line">    List&lt;String&gt; onMissingClasses = getCandidates(metadata, ConditionalOnMissingClass.class);</span><br><span class="line">    <span class="keyword">if</span> (onMissingClasses != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 执行匹配，看看是有多余的</span></span><br><span class="line">        List&lt;String&gt; present = filter(onMissingClasses, ClassNameFilter.PRESENT, classLoader);</span><br><span class="line">        <span class="comment">// 如果有不匹配的，返回不匹配信息</span></span><br><span class="line">        <span class="keyword">if</span> (!present.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnMissingClass.class)</span><br><span class="line">                    .found(<span class="string">"unwanted class"</span>, <span class="string">"unwanted classes"</span>).items(Style.QUOTE, present));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果匹配，添加到 matchMessage 中</span></span><br><span class="line">        matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</span><br><span class="line">                .didNotFind(<span class="string">"unwanted class"</span>, <span class="string">"unwanted classes"</span>).items(Style.QUOTE, filter(onMissingClasses, ClassNameFilter.MISSING, classLoader));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;4&gt; 返回匹配的结果</span></span><br><span class="line">    <span class="keyword">return</span> ConditionOutcome.match(matchMessage);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，声明变量。</li>
<li><code>&lt;2&gt;</code> 处，获得 <code>@ConditionalOnClass</code> 注解的属性。后续的，通过使用 <a href="#">「7.2.3 filter」</a> 方法，看看是否有缺失的类。</li>
<li><code>&lt;3&gt;</code> 处，获得 <code>@ConditionalOnMissingClass</code> 注解的属性。后续的，通过使用 <a href="#">「7.2.3 filter」</a> 方法，看看是否有多余的类。</li>
<li><code>&lt;4&gt;</code> 处，返回匹配的结果。</li>
</ul>
<h2 id="8-2-OnWebApplicationCondition"><a href="#8-2-OnWebApplicationCondition" class="headerlink" title="8.2 OnWebApplicationCondition"></a>8.2 OnWebApplicationCondition</h2><p><code>org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</code> ，继承 FilteringSpringBootCondition 抽象类，给 <code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 使用的 Condition 实现类。</p>
<h3 id="8-2-1-getOutcomes"><a href="#8-2-1-getOutcomes" class="headerlink" title="8.2.1 getOutcomes"></a>8.2.1 getOutcomes</h3><p><code>#getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 来自 FilteringSpringBootCondition 抽象类</span></span><br><span class="line"><span class="keyword">protected</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建 outcomes 结果数组</span></span><br><span class="line">    ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[autoConfigurationClasses.length];</span><br><span class="line">    <span class="comment">// &lt;2&gt; 遍历 autoConfigurationClasses 数组，执行匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcomes.length; i++) {</span><br><span class="line">        <span class="comment">// 获得配置类</span></span><br><span class="line">        String autoConfigurationClass = autoConfigurationClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (autoConfigurationClass != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 执行匹配</span></span><br><span class="line">            outcomes[i] = getOutcome(autoConfigurationMetadata.get(autoConfigurationClass,  <span class="string">"ConditionalOnWebApplication"</span>)); <span class="comment">// 获得 @ConditionalOnWebApplication 注解</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> outcomes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，创建 <code>outcomes</code> 结果数组。</li>
<li><p><code>&lt;2&gt;</code> 处，遍历 <code>autoConfigurationClasses</code> 数组，调用 <code>#getOutcome(String type)</code> 方法，执行匹配。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_WEB_APPLICATION_CLASS = <span class="string">"org.springframework.web.context.support.GenericWebApplicationContext"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACTIVE_WEB_APPLICATION_CLASS = <span class="string">"org.springframework.web.reactive.HandlerResult"</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String type)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnWebApplication.class);</span><br><span class="line">    <span class="comment">// &lt;2.1&gt; 如果要求 SERVLET 类型，结果不存在 SERVLET_WEB_APPLICATION_CLASS 类，返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (ConditionalOnWebApplication.Type.SERVLET.name().equals(type)) {</span><br><span class="line">        <span class="keyword">if</span> (!ClassNameFilter.isPresent(SERVLET_WEB_APPLICATION_CLASS, getBeanClassLoader())) {</span><br><span class="line">            <span class="keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="string">"servlet web application classes"</span>).atAll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2.2&gt; 如果要求 REACTIVE 类型，结果不存在 REACTIVE_WEB_APPLICATION_CLASS 类，返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (ConditionalOnWebApplication.Type.REACTIVE.name().equals(type)) {</span><br><span class="line">        <span class="keyword">if</span> (!ClassNameFilter.isPresent(REACTIVE_WEB_APPLICATION_CLASS, getBeanClassLoader())) {</span><br><span class="line">            <span class="keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="string">"reactive web application classes"</span>).atAll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2.3&gt; 如果 SERVLET_WEB_APPLICATION_CLASS 和 REACTIVE_WEB_APPLICATION_CLASS 都不存在，返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!ClassNameFilter.isPresent(SERVLET_WEB_APPLICATION_CLASS, getBeanClassLoader())</span><br><span class="line">            &amp;&amp; !ClassUtils.isPresent(REACTIVE_WEB_APPLICATION_CLASS, getBeanClassLoader())) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="string">"reactive or servlet web application classes"</span>).atAll());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;2.1&gt;</code> 处，如果要求 <code>SERVLET</code> 类型，结果不存在 <code>SERVLET_WEB_APPLICATION_CLASS</code> 类，返回不匹配。</li>
<li><code>&lt;2.2&gt;</code> 处，如果要求 <code>REACTIVE</code> 类型，结果不存在 <code>REACTIVE_WEB_APPLICATION_CLASS</code> 类，返回不匹配。</li>
<li><code>&lt;2.3&gt;</code> 处，如果 <code>SERVLET_WEB_APPLICATION_CLASS</code> 和 <code>REACTIVE_WEB_APPLICATION_CLASS</code> 都不存在，返回不匹配。</li>
</ul>
</li>
</ul>
<h3 id="8-2-2-getMatchOutcome"><a href="#8-2-2-getMatchOutcome" class="headerlink" title="8.2.2 getMatchOutcome"></a>8.2.2 getMatchOutcome</h3><p><code>#getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 来自 SpringBootCondition 抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 通过是否有 @ConditionalOnWebApplication 注解，判断是否要求在 Web 环境下</span></span><br><span class="line">    <span class="keyword">boolean</span> required = metadata.isAnnotated(ConditionalOnWebApplication.class.getName());</span><br><span class="line">    <span class="comment">// &lt;2&gt; 判断是否匹配 Web 环境</span></span><br><span class="line">    ConditionOutcome outcome = isWebApplication(context, metadata, required);</span><br><span class="line">    <span class="comment">// &lt;3.1&gt; 如果要求，结果不匹配 Web 环境，返回最终不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (required &amp;&amp; !outcome.isMatch()) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(outcome.getConditionMessage());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.2&gt; 如果不要求，结果匹配 Web 环境，返回最终不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!required &amp;&amp; outcome.isMatch()) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(outcome.getConditionMessage());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.3&gt; 返回匹配</span></span><br><span class="line">    <span class="keyword">return</span> ConditionOutcome.match(outcome.getConditionMessage());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，通过是否有 <code>@ConditionalOnWebApplication</code> 注解，判断是否要求在 Web 环境下。为什么能这么判断呢？因为 <code>@ConditionalOnNotWebApplication</code> 注解，也能走进这个方法，但是如果没有 <code>@ConditionalOnWebApplication</code> 注解，就意味着有 <code>@ConditionalOnNotWebApplication</code> 注解，也就是不要求 Web 环境。😈 是不是有点绕~</li>
<li><code>&lt;2&gt;</code> 处，调用 <code>#isWebApplication(ConditionContext context, AnnotatedTypeMetadata metadata, boolean required)</code> 方法，判断是否匹配 Web 环境。详细解析，见 <a href="#">「8.2.3 isWebApplication」</a> 。</li>
<li><code>&lt;3.1&gt;</code> 处，如果要求，结果不匹配 Web 环境，返回最终不匹配。</li>
<li><code>&lt;3.2&gt;</code> 处，如果不要求，结果匹配 Web 环境，返回最终不匹配。</li>
<li><code>&lt;3.3&gt;</code> 处，返回匹配。</li>
</ul>
<h3 id="8-2-3-isWebApplication"><a href="#8-2-3-isWebApplication" class="headerlink" title="8.2.3 isWebApplication"></a>8.2.3 isWebApplication</h3><p><code>#isWebApplication(ConditionContext context, AnnotatedTypeMetadata metadata, boolean required)</code> 方法，判断是否匹配 Web 环境。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">isWebApplication</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata, <span class="keyword">boolean</span> required)</span> </span>{</span><br><span class="line">	<span class="keyword">switch</span> (deduceType(metadata)) { <span class="comment">// &lt;1&gt; 获得要求的 Web 类型</span></span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">            <span class="keyword">return</span> isServletWebApplication(context); <span class="comment">// &lt;2.1&gt; 判断是否 Servlet Web 环境</span></span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            <span class="keyword">return</span> isReactiveWebApplication(context); <span class="comment">// &lt;2.2&gt; 判断是否 Reactive Web 环境</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> isAnyWebApplication(context, required); <span class="comment">// &lt;2.3&gt; 判断是否为任意 Web 环境</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#deduceType(AnnotatedTypeMetadata metadata)</code> 方法，获得要求的 Web 类型。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Type <span class="title">deduceType</span><span class="params">(AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">	Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(ConditionalOnWebApplication.class.getName());</span><br><span class="line">	<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> (Type) attributes.get(<span class="string">"type"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Type.ANY;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;2.1&gt;</code> 处，调用 <code>#isServletWebApplication(context)</code> 方法，判断是否 Servlet Web 环境。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">isServletWebApplication</span><span class="params">(ConditionContext context)</span> </span>{</span><br><span class="line">    ConditionMessage.Builder message = ConditionMessage.forCondition(<span class="string">""</span>);</span><br><span class="line">    <span class="comment">// 如果不存在 SERVLET_WEB_APPLICATION_CLASS 类，返回不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!ClassNameFilter.isPresent(SERVLET_WEB_APPLICATION_CLASS, context.getClassLoader())) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="string">"servlet web application classes"</span>).atAll());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (context.getBeanFactory() != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果不存在 session scope ，返回不匹配</span></span><br><span class="line">        String[] scopes = context.getBeanFactory().getRegisteredScopeNames();</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.containsElement(scopes, <span class="string">"session"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> ConditionOutcome.match(message.foundExactly(<span class="string">"'session' scope"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果 environment 是 ConfigurableWebEnvironment 类型，返回匹配！！！</span></span><br><span class="line">    <span class="keyword">if</span> (context.getEnvironment() <span class="keyword">instanceof</span> ConfigurableWebEnvironment) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.match(message.foundExactly(<span class="string">"ConfigurableWebEnvironment"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果 resourceLoader 是 WebApplicationContext 类型，返回匹配！！！</span></span><br><span class="line">    <span class="keyword">if</span> (context.getResourceLoader() <span class="keyword">instanceof</span> WebApplicationContext) {</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.match(message.foundExactly(<span class="string">"WebApplicationContext"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果 resourceLoader 不是 WebApplicationContext 类型，返回不匹配</span></span><br><span class="line">    <span class="keyword">return</span> ConditionOutcome.noMatch(message.because(<span class="string">"not a servlet web application"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;2.2&gt;</code> 处，调用 <code>#isReactiveWebApplication(ConditionContext context)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">isReactiveWebApplication</span><span class="params">(ConditionContext context)</span> </span>{</span><br><span class="line">	ConditionMessage.Builder message = ConditionMessage.forCondition(<span class="string">""</span>);</span><br><span class="line">	<span class="comment">// 如果不存在 REACTIVE_WEB_APPLICATION_CLASS 类，返回不匹配</span></span><br><span class="line">	<span class="keyword">if</span> (!ClassNameFilter.isPresent(REACTIVE_WEB_APPLICATION_CLASS, context.getClassLoader())) {</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="string">"reactive web application classes"</span>).atAll());</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果 environment 是 ConfigurableReactiveWebEnvironment 类型，返回匹配</span></span><br><span class="line">	<span class="keyword">if</span> (context.getEnvironment() <span class="keyword">instanceof</span> ConfigurableReactiveWebEnvironment) {</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.match(message.foundExactly(<span class="string">"ConfigurableReactiveWebEnvironment"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果 resourceLoader 是 ConfigurableReactiveWebEnvironment 类型，返回匹配</span></span><br><span class="line">	<span class="keyword">if</span> (context.getResourceLoader() <span class="keyword">instanceof</span> ReactiveWebApplicationContext) {</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.match(message.foundExactly(<span class="string">"ReactiveWebApplicationContext"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 返回不匹配</span></span><br><span class="line">	<span class="keyword">return</span> ConditionOutcome.noMatch(message.because(<span class="string">"not a reactive web application"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;2.3&gt;</code> 处，调用 <code>#isAnyWebApplication(ConditionContext context, boolean required)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// OnWebApplicationCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">isAnyWebApplication</span><span class="params">(ConditionContext context, <span class="keyword">boolean</span> required)</span> </span>{</span><br><span class="line">	ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnWebApplication.class, required ? <span class="string">"(required)"</span> : <span class="string">""</span>);</span><br><span class="line">	<span class="comment">// 如果是 Servlet 环境，并且要求 WEB 环境，返回匹配</span></span><br><span class="line">	ConditionOutcome servletOutcome = isServletWebApplication(context);</span><br><span class="line">	<span class="keyword">if</span> (servletOutcome.isMatch() &amp;&amp; required) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConditionOutcome(servletOutcome.isMatch(), message.because(servletOutcome.getMessage()));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果是 Reactive 环境，并且要求 WEB 环境，返回匹配</span></span><br><span class="line">	ConditionOutcome reactiveOutcome = isReactiveWebApplication(context);</span><br><span class="line">	<span class="keyword">if</span> (reactiveOutcome.isMatch() &amp;&amp; required) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConditionOutcome(reactiveOutcome.isMatch(), message.because(reactiveOutcome.getMessage()));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 根据情况，返回是否匹配</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ConditionOutcome(servletOutcome.isMatch() || reactiveOutcome.isMatch(), <span class="comment">// 要求 Servlet 环境 or Reactive 环境，其中有一个匹配</span></span><br><span class="line">			message.because(servletOutcome.getMessage()).append(<span class="string">"and"</span>).append(reactiveOutcome.getMessage()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="8-3-OnBeanCondition"><a href="#8-3-OnBeanCondition" class="headerlink" title="8.3 OnBeanCondition"></a>8.3 OnBeanCondition</h2><p><code>org.springframework.boot.autoconfigure.condition.OnBeanCondition</code> ，继承 FilteringSpringBootCondition 抽象类，给 <code>@ConditionalOnBean</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnSingleCandidate</code> 使用的 Condition 实现类。</p>
<p>艿艿就暂时先不写了，因为这个类有点复杂，我想偷懒，哈哈哈。当然，感兴趣的胖友，可以看看 <a href="https://blog.csdn.net/xcy1193068639/article/details/81517456" rel="external nofollow noopener noreferrer" target="_blank">《SpringBoot @ConditionalOnBean、@ConditionalOnMissingBean 注解源码分析与示例》</a> 一文。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文以为是一篇半天就能解决的博客，结果写了一天半。希望尽可能覆盖到大多数细节。😈</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>dm_vincent <ul>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/77435515" rel="external nofollow noopener noreferrer" target="_blank">《[Spring Boot] 3. Spring Boot实现自动配置的基础》</a></li>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/77619752" rel="external nofollow noopener noreferrer" target="_blank">《[Spring Boot] 4. Spring Boot实现自动配置的原理》</a></li>
</ul>
</li>
<li>oldflame-Jm <a href="https://blog.csdn.net/jamet/article/details/78505708" rel="external nofollow noopener noreferrer" target="_blank">《Spring boot源码分析-Conditional（12）》</a></li>
<li>一个努力的码农 <a href="https://blog.csdn.net/qq_26000415/article/details/79008745" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析19-@Conditional注解详解》</a></li>
<li><p>快乐崇拜 <a href="https://gitbook.cn/books/5a445f030173cb29d2041d61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 源码深入分析》</a></p>
<blockquote>
<p>有木发现，艿艿写的比他详细很多很多。</p>
</blockquote>
</li>
</ul>




</div>