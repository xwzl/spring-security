<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来补充 <a href="http://svip.iocoder.cn/Spring-Boot/SpringApplication">《精尽 Spring Boot 源码分析 —— SpringApplication》</a> 文章，并未详细解析的 BeanDefinitionLoader 。在 SpringApplication 中，我们可以看到 <code>#load(ApplicationContext context, Object[] sources)</code> 方法中，是如下一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">		logger.debug(<span class="string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 BeanDefinitionLoader 对象</span></span><br><span class="line">	BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">	<span class="comment">// &lt;2&gt; 设置 loader 的属性</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;3&gt; 执行 BeanDefinition 加载</span></span><br><span class="line">	loader.load();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionLoader <span class="title">createBeanDefinitionLoader</span><span class="params">(BeanDefinitionRegistry registry, Object[] sources)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionLoader(registry, sources);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面，我们来一起揭开它的面纱~</p>
<h1 id="2-BeanDefinitionLoader"><a href="#2-BeanDefinitionLoader" class="headerlink" title="2. BeanDefinitionLoader"></a>2. BeanDefinitionLoader</h1><p><code>org.springframework.boot.BeanDefinitionLoader</code> ，BeanDefinition 加载器（Loader），负责 Spring Boot 中，读取 BeanDefinition 。其类上的注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads bean definitions from underlying sources, including XML and JavaConfig. Acts as a</span></span><br><span class="line"><span class="comment"> * simple facade over {<span class="doctag">@link</span> AnnotatedBeanDefinitionReader},</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> XmlBeanDefinitionReader} and {<span class="doctag">@link</span> ClassPathBeanDefinitionScanner}. See</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> SpringApplication} for the types of sources that are supported.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] sources;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解的 BeanDefinition 读取器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader annotatedReader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XML 的 BeanDefinition 读取器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader xmlReader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Groovy 的 BeanDefinition 读取器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionReader groovyReader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Classpath 的 BeanDefinition 扫描器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> BeanDefinitionLoader} that will load beans into the specified</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> BeanDefinitionRegistry}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean definition registry that will contain the loaded beans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the bean sources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {</span><br><span class="line">    Assert.notNull(registry, <span class="string">"Registry must not be null"</span>);</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sources = sources; <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    <span class="comment">// 创建 AnnotatedBeanDefinitionReader 对象</span></span><br><span class="line">    <span class="keyword">this</span>.annotatedReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(registry);</span><br><span class="line">    <span class="comment">// 创建 XmlBeanDefinitionReader 对象</span></span><br><span class="line">    <span class="keyword">this</span>.xmlReader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);</span><br><span class="line">    <span class="comment">// 创建 GroovyBeanDefinitionReader 对象</span></span><br><span class="line">    <span class="keyword">if</span> (isGroovyPresent()) {</span><br><span class="line">        <span class="keyword">this</span>.groovyReader = <span class="keyword">new</span> GroovyBeanDefinitionReader(registry);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建 ClassPathBeanDefinitionScanner 对象</span></span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(registry);</span><br><span class="line">    <span class="keyword">this</span>.scanner.addExcludeFilter(<span class="keyword">new</span> ClassExcludeFilter(sources));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，设置 <code>sources</code> 属性。它来自方法参数 <code>Object... sources</code> ，来自 <code>SpringApplication#getAllSources()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要的 Java Config 类的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; primarySources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; sources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an immutable set of all the sources that will be added to an</span></span><br><span class="line"><span class="comment"> * ApplicationContext when {<span class="doctag">@link</span> #run(String...)} is called. This method combines any</span></span><br><span class="line"><span class="comment"> * primary sources specified in the constructor with any additional ones that have</span></span><br><span class="line"><span class="comment"> * been {<span class="doctag">@link</span> #setSources(Set) explicitly set}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an immutable set of all sources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">getAllSources</span><span class="params">()</span> </span>{</span><br><span class="line">	Set&lt;Object&gt; allSources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.primarySources)) {</span><br><span class="line">		allSources.addAll(<span class="keyword">this</span>.primarySources);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.sources)) {</span><br><span class="line">		allSources.addAll(<span class="keyword">this</span>.sources);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Collections.unmodifiableSet(allSources);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认情况下，返回的结果是 <code>Spring#run(Class&lt;?&gt; primarySource, String... args)</code> 方法的 <code>Class&lt;?&gt; primarySource</code> 的方法参数。例如说：<a href="https://github.com/YunaiV/spring-boot/blob/74690873857801615f1bf404c229a29986b96238/spring-boot-tests/spring-boot-yunai-tests/spring-boot-yunai-mvc-tests/src/main/java/cn/iocoder/springboot/mvc/MVCApplication.java" rel="external nofollow noopener noreferrer" target="_blank">MVCApplication</a> 。</li>
</ul>
</li>
<li><p><code>&lt;2.1&gt;</code> 处，创建 AnnotatedBeanDefinitionReader 对象，设置给 <code>annotatedReader</code> 属性。</p>
</li>
<li><code>&lt;2.2&gt;</code> 处，创建 XmlBeanDefinitionReader 对象，设置给 <code>xmlReader</code> 属性。</li>
<li><p><code>&lt;2.3&gt;</code> 处，创建 GroovyBeanDefinitionReader 对象，设置给 <code>groovyReader</code> 属性。其中，<code>#isGroovyPresent()</code> 方法，判断是否可以使用 Groovy 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGroovyPresent</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> ClassUtils.isPresent(<span class="string">"groovy.lang.MetaClass"</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;2.4&gt;</code> 处，创建 ClassPathBeanDefinitionScanner 对象，并设置给 <code>scanner</code> 属性。其中，ClassExcludeFilter 是 BeanDefinitionLoader 的内部静态类，继承 AbstractTypeHierarchyTraversingFilter 抽象类，用于排除对 <code>sources</code> 的扫描。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple {<span class="doctag">@link</span> TypeFilter} used to ensure that specified {<span class="doctag">@link</span> Class} sources are</span></span><br><span class="line"><span class="comment"> * not accidentally re-added during scanning.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassExcludeFilter</span> <span class="keyword">extends</span> <span class="title">AbstractTypeHierarchyTraversingFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; classNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	ClassExcludeFilter(Object... sources) {</span><br><span class="line">		<span class="keyword">super</span>(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (Object source : sources) {</span><br><span class="line">			<span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) {</span><br><span class="line">				<span class="keyword">this</span>.classNames.add(((Class&lt;?&gt;) source).getName());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.classNames.contains(className);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果不排除，则会出现重复读取 BeanDefinition 的情况。</li>
</ul>
</li>
</ul>
<h2 id="2-2-setBeanNameGenerator"><a href="#2-2-setBeanNameGenerator" class="headerlink" title="2.2 setBeanNameGenerator"></a>2.2 setBeanNameGenerator</h2><p><code>#setBeanNameGenerator(BeanNameGenerator beanNameGenerator)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the bean name generator to be used by the underlying readers and scanner.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanNameGenerator the bean name generator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanNameGenerator</span><span class="params">(BeanNameGenerator beanNameGenerator)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.annotatedReader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">	<span class="keyword">this</span>.xmlReader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">	<span class="keyword">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-3-setResourceLoader"><a href="#2-3-setResourceLoader" class="headerlink" title="2.3 setResourceLoader"></a>2.3 setResourceLoader</h2><p><code>#setResourceLoader(ResourceLoader resourceLoader)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the resource loader to be used by the underlying readers and scanner.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceLoader the resource loader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">	<span class="keyword">this</span>.xmlReader.setResourceLoader(resourceLoader);</span><br><span class="line">	<span class="keyword">this</span>.scanner.setResourceLoader(resourceLoader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-4-setEnvironment"><a href="#2-4-setEnvironment" class="headerlink" title="2.4 setEnvironment"></a>2.4 setEnvironment</h2><p><code>#setEnvironment(ConfigurableEnvironment environment)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the environment to be used by the underlying readers and scanner.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment the environment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.annotatedReader.setEnvironment(environment);</span><br><span class="line">	<span class="keyword">this</span>.xmlReader.setEnvironment(environment);</span><br><span class="line">	<span class="keyword">this</span>.scanner.setEnvironment(environment);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-5-load"><a href="#2-5-load" class="headerlink" title="2.5 load"></a>2.5 load</h2><p><code>#load()</code> 方法，执行 BeanDefinition 加载。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the sources into the reader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of loaded beans</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  遍历 sources 数组，逐个加载</span></span><br><span class="line">    <span class="keyword">for</span> (Object source : <span class="keyword">this</span>.sources) {</span><br><span class="line">        count += load(source);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Object source)</span> </span>{</span><br><span class="line">    Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果是 Class 类型，则使用 AnnotatedBeanDefinitionReader 执行加载</span></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) {</span><br><span class="line">        <span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;2&gt; 如果是 Resource 类型，则使用 XmlBeanDefinitionReader 执行加载</span></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) {</span><br><span class="line">        <span class="keyword">return</span> load((Resource) source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3&gt; 如果是 Package 类型，则使用 ClassPathBeanDefinitionScanner 执行加载</span></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) {</span><br><span class="line">        <span class="keyword">return</span> load((Package) source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;4&gt; 如果是 CharSequence 类型，则各种尝试去加载</span></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) {</span><br><span class="line">        <span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;5&gt; 无法处理的类型，抛出 IllegalArgumentException 异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid source type "</span> + source.getClass());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>针对不同 <code>source</code> 类型，执行不同的加载逻辑。</li>
<li><code>&lt;1&gt;</code> 处，如果是 Class 类型，则调用 <code>#load(Class&lt;?&gt; source)</code> 方法，使用 AnnotatedBeanDefinitionReader 执行加载。详细解析，见 <a href="#">「2.5.1 load(Class&lt;?&gt; source)」</a> 。</li>
<li><code>&lt;2&gt;</code> 处，如果是 Resource 类型，则调用 <code>#load(Resource source)</code> 方法，使用 XmlBeanDefinitionReader 执行加载。详细解析，见 <a href="#">「2.5.2 load(Resource source)」</a> 。</li>
<li><code>&lt;3&gt;</code> 处，如果是 Package 类型，则调用 <code>#load(Package source)</code> 方法，使用 ClassPathBeanDefinitionScanner 执行加载。详细解析，见 <a href="#">「2.5.3 load(Package source)」</a> 。</li>
<li><code>&lt;4&gt;</code> 处，如果是 CharSequence 类型，则调用 <code>#load(CharSequence source)</code> 方法，各种尝试去加载。例如说 <code>source</code> 为 <code>"classpath:/applicationContext.xml"</code> 。详细解析，见 <a href="#">「2.5.4 load(CharSequence source)」</a> 。</li>
<li><code>&lt;5&gt;</code> 处，无法处理的类型，抛出 IllegalArgumentException 异常。</li>
</ul>
<h3 id="2-5-1-load-Class-lt-gt-source"><a href="#2-5-1-load-Class-lt-gt-source" class="headerlink" title="2.5.1 load(Class<?> source)"></a>2.5.1 load(Class&lt;?&gt; source)</h3><p><code>#load(Class&lt;?&gt; source)</code> 方法，使用 AnnotatedBeanDefinitionReader 执行加载。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>{</span><br><span class="line">    <span class="comment">// Groovy 相关，暂时忽略</span></span><br><span class="line">    <span class="keyword">if</span> (isGroovyPresent()</span><br><span class="line">            &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {</span><br><span class="line">        <span class="comment">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span></span><br><span class="line">        GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">        load(loader);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果是 Component ，则执行注册</span></span><br><span class="line">    <span class="keyword">if</span> (isComponent(source)) {</span><br><span class="line">        <span class="keyword">this</span>.annotatedReader.register(source); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#isComponent(Class&lt;?&gt; type)</code> 方法，判断是否为 Component 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isComponent</span><span class="params">(Class&lt;?&gt; type)</span> </span>{</span><br><span class="line">    <span class="comment">// This has to be a bit of a guess. The only way to be sure that this type is</span></span><br><span class="line">    <span class="comment">// eligible is to make a bean definition out of it and try to instantiate it.</span></span><br><span class="line">    <span class="comment">// 如果有 @Component 注解，则返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotationUtils.findAnnotation(type, Component.class) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Nested anonymous classes are not eligible for registration, nor are groovy</span></span><br><span class="line">    <span class="comment">// closures</span></span><br><span class="line">    <span class="comment">// 暂时忽略</span></span><br><span class="line">    <span class="keyword">if</span> (type.getName().matches(<span class="string">".*\\$_.*closure.*"</span>) || type.isAnonymousClass()</span><br><span class="line">            || type.getConstructors() == <span class="keyword">null</span> || type.getConstructors().length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为 Configuration 类，上面有 <code>@Configuration</code> 注解，而 <code>@Configuration</code> 上，自带 <code>@Component</code> 注解，所以该方法返回 <code>true</code> 。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>AnnotatedBeanDefinitionReader#register(Class&lt;?&gt;... annotatedClasses)</code> 方法，执行注册。</p>
</li>
</ul>
<h3 id="2-5-2-load-Resource-source"><a href="#2-5-2-load-Resource-source" class="headerlink" title="2.5.2 load(Resource source)"></a>2.5.2 load(Resource source)</h3><p><code>#load(Resource source)</code> 方法，使用 XmlBeanDefinitionReader 执行加载。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Resource source)</span> </span>{</span><br><span class="line">    <span class="comment">// Groovy 相关，暂时忽略</span></span><br><span class="line">    <span class="keyword">if</span> (source.getFilename().endsWith(<span class="string">".groovy"</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.groovyReader == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot load Groovy beans without Groovy on classpath"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.groovyReader.loadBeanDefinitions(source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用 XmlBeanDefinitionReader 加载 BeanDefinition</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.xmlReader.loadBeanDefinitions(source);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <code>XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)</code> 方法，从 XML 中加载 BeanDefinition 。</li>
</ul>
<h3 id="2-5-3-load-Package-source"><a href="#2-5-3-load-Package-source" class="headerlink" title="2.5.3 load(Package source)"></a>2.5.3 load(Package source)</h3><p><code>#load(Package source)</code> 方法，使用 ClassPathBeanDefinitionScanner 执行加载。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Package source)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.scanner.scan(source.getName());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-4-load-CharSequence-source"><a href="#2-5-4-load-CharSequence-source" class="headerlink" title="2.5.4 load(CharSequence source)"></a>2.5.4 load(CharSequence source)</h3><p><code>#load(CharSequence source)</code> 方法，各种尝试去加载。代码如下：</p>
<blockquote>
<p> 按照 <code>source</code> 是 Class &gt; Resource &gt; Package 的顺序，尝试加载。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(CharSequence source)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 解析 source 。因为，有可能里面带有占位符。</span></span><br><span class="line">    String resolvedSource = <span class="keyword">this</span>.xmlReader.getEnvironment().resolvePlaceholders(source.toString());</span><br><span class="line">    <span class="comment">// &lt;2&gt; 尝试按照 Class 进行加载</span></span><br><span class="line">    <span class="comment">// Attempt as a Class</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> load(ClassUtils.forName(resolvedSource, <span class="keyword">null</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException | ClassNotFoundException ex) {</span><br><span class="line">        <span class="comment">// swallow exception and continue</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3&gt; 尝试按照 Resource 进行加载</span></span><br><span class="line">    <span class="comment">// Attempt as resources</span></span><br><span class="line">    Resource[] resources = findResources(resolvedSource); <span class="comment">// &lt;3.1&gt;</span></span><br><span class="line">    <span class="keyword">int</span> loadCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> atLeastOneResourceExists = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) {</span><br><span class="line">        <span class="keyword">if</span> (isLoadCandidate(resource)) { <span class="comment">// &lt;3.2&gt;</span></span><br><span class="line">            atLeastOneResourceExists = <span class="keyword">true</span>;</span><br><span class="line">            loadCount += load(resource); <span class="comment">// &lt;3.3&gt;</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (atLeastOneResourceExists) { <span class="comment">// &lt;3.4&gt; 有加载到，则认为成功，返回。</span></span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Attempt as package</span></span><br><span class="line">    <span class="comment">// &lt;4&gt; 尝试按照 Package 进行加载</span></span><br><span class="line">    Package packageResource = findPackage(resolvedSource); <span class="comment">// &lt;4.1&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (packageResource != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> load(packageResource); <span class="comment">// &lt;4.2&gt;</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;5&gt; 无法处理，抛出 IllegalArgumentException 异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid source '"</span> + resolvedSource + <span class="string">"'"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>&lt;1&gt;</code> 处，解析 <code>source</code> 。因为，有可能里面带有占位符。</li>
<li><code>&lt;2&gt;</code> 处，将 <code>source</code> 转换成 Class ，然后执行 <a href="#">「2.5.1 load(Class&lt;?&gt; source)」</a> 的流程。</li>
<li><code>&lt;3&gt;</code> 处，尝试按照 Resource 进行加载。</li>
<li><p><code>&lt;3.1&gt;</code> 处，调用 <code>#findResources(String source)</code> 方法，获得 <code>source</code> 对应的 Resource 数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource[] findResources(String source) {</span><br><span class="line">    <span class="comment">// 创建 ResourceLoader 对象</span></span><br><span class="line">    ResourceLoader loader = (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) ? <span class="keyword">this</span>.resourceLoader : <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获得 Resource 数组</span></span><br><span class="line">        <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> ResourcePatternResolver) {</span><br><span class="line">            <span class="keyword">return</span> ((ResourcePatternResolver) loader).getResources(source);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获得 Resource 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource[] { loader.getResource(source) };</span><br><span class="line">    } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error reading source '"</span> + source + <span class="string">"'"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;3.2&gt;</code> 处，遍历 <code>resources</code> 数组，调用 <code>#isLoadCandidate(Resource resource)</code> 方法，判断是否为符合条件的 Resource 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLoadCandidate</span><span class="params">(Resource resource)</span> </span>{</span><br><span class="line">    <span class="comment">// 不存在，则返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="keyword">null</span> || !resource.exists()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断 resource 是 ClassPathResource 类，不是一个 package</span></span><br><span class="line">    <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> ClassPathResource) {</span><br><span class="line">        <span class="comment">// A simple package without a '.' may accidentally get loaded as an XML</span></span><br><span class="line">        <span class="comment">// document if we're not careful. The result of getInputStream() will be</span></span><br><span class="line">        <span class="comment">// a file list of the package content. We double check here that it's not</span></span><br><span class="line">        <span class="comment">// actually a package.</span></span><br><span class="line">        String path = ((ClassPathResource) resource).getPath();</span><br><span class="line">        <span class="keyword">if</span> (path.indexOf(<span class="string">'.'</span>) == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> Package.getPackage(path) == <span class="keyword">null</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回 true ，符合条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>&lt;3.3&gt;</code> 处，执行 <a href="#">「2.5.2 load(Resource source)」</a> 的流程。</p>
</li>
<li><code>&lt;3.4&gt;</code> 处，有加载到，则认为成功，返回。</li>
<li><code>&lt;4&gt;</code> 处，尝试按照 Package 进行加载。</li>
<li><p><code>&lt;4.1&gt;</code> 处，调用 <code>#findPackage(CharSequence source)</code> 方法，获得 Package 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">findPackage</span><span class="params">(CharSequence source)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;X&gt; 获得 source 对应的 Package 。如果存在，则返回</span></span><br><span class="line">    Package pkg = Package.getPackage(source.toString());</span><br><span class="line">    <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> pkg;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// Attempt to find a class in this package</span></span><br><span class="line">        <span class="comment">// 创建 ResourcePatternResolver 对象</span></span><br><span class="line">        ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 尝试加载 source 目录下的 class 们</span></span><br><span class="line">        Resource[] resources = resolver.getResources(ClassUtils.convertClassNameToResourcePath(source.toString()) + <span class="string">"/*.class"</span>);</span><br><span class="line">        <span class="comment">// 遍历 resources 数组</span></span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) {</span><br><span class="line">            <span class="comment">// 获得类名</span></span><br><span class="line">            String className = StringUtils.stripFilenameExtension(resource.getFilename());</span><br><span class="line">            <span class="comment">// 按照 Class 进行加载 BeanDefinition</span></span><br><span class="line">            load(Class.forName(source.toString() + <span class="string">"."</span> + className));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="comment">// swallow exception and continue</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回 Package</span></span><br><span class="line">    <span class="keyword">return</span> Package.getPackage(source.toString());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然逻辑比较复杂，我们只需要看看 <code>&lt;X&gt;</code> 处的前半部分的逻辑即可。</li>
</ul>
</li>
<li><code>&lt;4.2&gt;</code> 处，执行 <a href="#">「2.5.3 load(Package source)」</a> 的流程。</li>
<li><code>&lt;5&gt;</code> 处，无法处理，抛出 IllegalArgumentException 异常。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>简单小文一篇。如果胖友不了解 Spring BeanDefinition ，可以补充看看 <a href="http://svip.iocoder.cn/Spring/IoC-load-BeanDefinitions/">《【死磕 Spring】—— IoC 之加载 BeanDefinition》</a> 文章。</p>
<p>如果想要测试 SpringFactoriesLoader 的各种情况，可以调试 BeanDefinitionLoaderTests 提供的单元测试。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>一个努力的码农 <a href="https://blog.csdn.net/qq_26000415/article/details/78915211" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析8-SpringApplication#run第8步》</a></li>
<li>oldflame-Jm <a href="https://blog.csdn.net/jamet/article/details/78291900" rel="external nofollow noopener noreferrer" target="_blank">《Spring boot源码分析-BeanDefinitionLoader（7）》</a></li>
</ul>
</div>